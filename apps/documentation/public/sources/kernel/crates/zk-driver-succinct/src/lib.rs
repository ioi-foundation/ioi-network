// Path: crates/zk-driver-succinct/src/lib.rs

pub mod config;
#[cfg(feature = "native")]
pub mod sp1_backend;

use crate::config::SuccinctDriverConfig;
use anyhow::Result;
use async_trait::async_trait;
use dcrypt::algorithms::hash::{HashFunction, Sha256};
use ioi_api::{
    error::CoreError,
    ibc::{AgentZkVerifier, IbcZkVerifier},
    zk::ZkProofSystem,
};
use ioi_types::ibc::StateProofScheme;
use std::sync::Arc; // [FIX] Added async_trait import

// Re-export canonical types from the shared crate
pub use zk_types::{BeaconPublicInputs, StateInclusionPublicInputs};

/// A dummy ZK backend for simulation, fulfilling the ZkProofSystem trait.
#[derive(Debug, Clone, Default)]
pub struct SimulatedGroth16;

impl ZkProofSystem for SimulatedGroth16 {
    type Proof = Vec<u8>;
    type VerifyingKey = (); // Mock
    type PublicInputs = Vec<u8>;

    fn verify(
        _vk: &Self::VerifyingKey,
        proof: &Self::Proof,
        public_inputs: &Self::PublicInputs,
    ) -> Result<bool, ioi_api::error::CryptoError> {
        // Simulation Rule: hash(proof) == state_root

        // Try to interpret inputs as BeaconPublicInputs
        let target_root: [u8; 32] = if let Ok(inputs) =
            bincode::deserialize::<BeaconPublicInputs>(public_inputs)
        {
            inputs.new_state_root
        }
        // Try to interpret inputs as StateInclusionPublicInputs
        else if let Ok(inputs) = bincode::deserialize::<StateInclusionPublicInputs>(public_inputs)
        {
            inputs.state_root
        }
        // Fallback for legacy/raw tests: assume inputs IS the root bytes directly
        else if public_inputs.len() == 32 {
            let mut root = [0u8; 32];
            root.copy_from_slice(public_inputs);
            root
        } else {
            return Err(ioi_api::error::CryptoError::InvalidInput(
                "Public inputs could not be deserialized to known struct or root".into(),
            ));
        };

        // Explicitly map the dcrypt error to CryptoError
        let hash = Sha256::digest(proof)
            .map_err(|e| ioi_api::error::CryptoError::OperationFailed(e.to_string()))?;

        Ok(hash.as_ref() == target_root.as_slice())
    }
}

/// A driver that verifies proofs generated by the Succinct platform.
#[derive(Debug, Clone)]
pub struct SuccinctDriver {
    _config: Arc<SuccinctDriverConfig>,
}

impl SuccinctDriver {
    pub fn new(config: SuccinctDriverConfig) -> Self {
        Self {
            _config: Arc::new(config),
        }
    }

    pub fn new_mock() -> Self {
        Self::new(SuccinctDriverConfig::default())
    }
}

impl Default for SuccinctDriver {
    fn default() -> Self {
        Self::new_mock()
    }
}

impl IbcZkVerifier for SuccinctDriver {
    fn verify_beacon_update(&self, proof: &[u8], public_inputs: &[u8]) -> Result<(), CoreError> {
        #[cfg(feature = "native")]
        {
            use crate::sp1_backend::Sp1ProofSystem;
            // In native mode, verify the SP1 proof against the configured vkey.
            let valid = Sp1ProofSystem::verify(
                &self._config.beacon_vkey_bytes,
                &proof.to_vec(),
                &public_inputs.to_vec(),
            )
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("SP1 Beacon Verification Failed".into()));
            }
            Ok(())
        }

        #[cfg(not(feature = "native"))]
        {
            // In mock mode, delegate to the simulation backend.
            let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &public_inputs.to_vec())
                .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
            }
            Ok(())
        }
    }

    fn verify_state_inclusion(
        &self,
        scheme: StateProofScheme,
        proof: &[u8],
        root: [u8; 32],
    ) -> Result<(), CoreError> {
        // Construct the canonical input struct locally.
        let inputs = StateInclusionPublicInputs {
            state_root: root,
            key: vec![],
            value: vec![],
            scheme_id: match scheme {
                StateProofScheme::Mpt => 0,
                StateProofScheme::Verkle => 1,
            },
        };

        let inputs_bytes = bincode::serialize(&inputs)
            .map_err(|e| CoreError::Custom(format!("Serialization failed: {}", e)))?;

        #[cfg(feature = "native")]
        {
            use crate::sp1_backend::Sp1ProofSystem;
            let valid = Sp1ProofSystem::verify(
                &self._config.state_inclusion_vkey_bytes,
                &proof.to_vec(),
                &inputs_bytes,
            )
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("SP1 State Verification Failed".into()));
            }
            Ok(())
        }

        #[cfg(not(feature = "native"))]
        {
            let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &inputs_bytes)
                .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
            }
            Ok(())
        }
    }
}

// [NEW] Implement AgentZkVerifier for SuccinctDriver
#[async_trait]
impl AgentZkVerifier for SuccinctDriver {
    async fn verify_inference(
        &self,
        proof: &[u8],
        model_hash: [u8; 32],
        input: &[u8],
        output: &[u8],
    ) -> Result<bool, CoreError> {
        // [MOCK] For now, we use a simple simulation rule:
        // Proof must be sha256(input || output || model_hash)

        let mut preimage = Vec::new();
        preimage.extend_from_slice(input);
        preimage.extend_from_slice(output);
        preimage.extend_from_slice(&model_hash);

        let expected_hash =
            Sha256::digest(&preimage).map_err(|e| CoreError::Crypto(e.to_string()))?;

        // Check if proof matches hash
        if proof == expected_hash.as_ref() {
            return Ok(true);
        }

        // In native mode, this would call SP1 verifier with an inference-specific VK
        // and public inputs = (model_hash, hash(input), hash(output))

        Ok(false)
    }
}

#[cfg(test)]
mod tests;
