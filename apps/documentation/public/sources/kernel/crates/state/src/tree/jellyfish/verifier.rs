// Path: crates/state/src/tree/jellyfish/verifier.rs

use crate::primitives::hash::{HashCommitment, HashProof};
use crate::tree::jellyfish::nibble::NibblePath;
use crate::tree::jellyfish::node::{InternalNode, LeafNode, Node, NodeHash};
use ioi_api::error::StateError;
use ioi_api::state::Verifier;
use ioi_crypto::algorithms::hash::sha256;
use ioi_types::app::Membership;
use ioi_types::error::ProofError;
use parity_scale_codec::{Decode, Encode};

/// Proof of membership or non-membership in a Jellyfish Merkle Tree.
/// This structure is serialized into the `value` field of the generic `HashProof`.
#[derive(Debug, Clone, PartialEq, Eq, Encode, Decode)]
pub struct JellyfishMerkleProof {
    /// The leaf node found at the path, if any.
    /// - If `Some(leaf)` and `leaf.account_key == key_hash`, it proves existence.
    /// - If `Some(leaf)` and `leaf.account_key != key_hash`, it proves non-existence (collision).
    /// - If `None`, it proves non-existence (empty subtree).
    pub leaf: Option<LeafNode>,

    /// The siblings for each level of the tree, starting from the root.
    /// Vector index corresponds to depth.
    /// Each element contains the siblings (nibble, hash) for the `InternalNode` at that depth.
    pub siblings: Vec<Vec<(u8, NodeHash)>>,
}

/// A stateless verifier for proofs generated by a `JellyfishMerkleTree` using a `HashCommitmentScheme`.
#[derive(Clone, Debug, Default)]
pub struct JellyfishVerifier;

impl Verifier for JellyfishVerifier {
    type Commitment = HashCommitment;
    type Proof = HashProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(HashCommitment::new(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof_obj: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> Result<(), ProofError> {
        let root_hash = root.as_ref();

        // 1. Decode the proof
        // The `create_proof` method in the JMT serializes the `JellyfishMerkleProof` struct
        // into the `value` field of the generic `HashProof`. We deserialize it here.
        let proof_data = proof_obj.value();
        let proof: JellyfishMerkleProof = Decode::decode(&mut &*proof_data)
            .map_err(|e| ProofError::Deserialization(e.to_string()))?;

        // 2. Hash key for path navigation
        // JMT uses the 32-byte SHA-256 hash of the key as the path (account_key).
        let key_hash = sha256(key).map_err(|e| ProofError::Crypto(e.to_string()))?;
        let mut key_hash_arr = [0u8; 32];
        key_hash_arr.copy_from_slice(&key_hash);
        let nibble_path = NibblePath::new(&key_hash_arr);

        // 3. Verify Outcome Match
        // We validate that the proof structure logically implies the claimed membership outcome.
        match (outcome, &proof.leaf) {
            (Membership::Present(val), Some(leaf)) => {
                // Existence proof: Keys must match, and Value Hash must match.
                if leaf.account_key != key_hash_arr {
                    return Err(ProofError::InvalidExistence("Leaf key mismatch".into()));
                }

                // Verify value hash.
                // The JMT stores H(value), not the value itself.
                let val_hash = sha256(val).map_err(|e| ProofError::Crypto(e.to_string()))?;
                if leaf.value_hash.as_slice() != val_hash.as_ref() {
                    return Err(ProofError::InvalidExistence(
                        "Proof leaf value hash mismatch".into(),
                    ));
                }
            }
            (Membership::Absent, Some(leaf)) => {
                // Non-existence proof (Collision): Keys must NOT match.
                // This proves we reached a leaf, but it wasn't the key we looked for,
                // meaning the key doesn't exist (because paths are deterministic).
                if leaf.account_key == key_hash_arr {
                    return Err(ProofError::InvalidNonExistence(
                        "Proof indicates existence, expected absence".into(),
                    ));
                }
            }
            (Membership::Absent, None) => {
                // Non-existence proof (Empty subtree): Valid.
                // The path led to a null node, proving the key is not in the tree.
            }
            (Membership::Present(_), None) => {
                return Err(ProofError::InvalidExistence(
                    "Proof claims empty leaf, expected existence".into(),
                ));
            }
        }

        // 4. Recompute Root Hash
        let computed_root = self.compute_root(&proof, &nibble_path)?;

        if computed_root.as_slice() != root_hash {
            return Err(ProofError::RootMismatch);
        }

        Ok(())
    }
}

impl JellyfishVerifier {
    /// Recomputes the Merkle root by traversing the proof path from leaf/empty up to the root.
    fn compute_root(
        &self,
        proof: &JellyfishMerkleProof,
        path: &NibblePath,
    ) -> Result<[u8; 32], ProofError> {
        // Start with the hash of the leaf (or Null if empty)
        let mut current_hash = match &proof.leaf {
            Some(leaf) => {
                // Compute leaf node hash: H(0x00 || key || value_hash)
                // This matches Node::Leaf hashing logic in node.rs, assuming HashCommitmentScheme.
                let mut preimage = vec![0x00];
                preimage.extend_from_slice(&leaf.account_key);
                preimage.extend_from_slice(&leaf.value_hash);
                let h = sha256(&preimage).map_err(|e| ProofError::Crypto(e.to_string()))?;
                let mut arr = [0u8; 32];
                arr.copy_from_slice(&h);
                arr
            }
            None => [0u8; 32], // Node::Null hash
        };

        // Traverse up from the leaf/empty point to the root.
        // proof.siblings is ordered from root (depth 0) to leaf (max depth).
        // We iterate in reverse to hash upwards.
        for (depth, siblings) in proof.siblings.iter().enumerate().rev() {
            let nibble = path.get_nibble(depth);

            // Reconstruct InternalNode children list
            let mut children = siblings.clone();

            // If current_hash is not null, it must be included in the children list.
            if current_hash != [0u8; 32] {
                // Sanity check: sibling list shouldn't already contain this nibble.
                if children.iter().any(|(n, _)| *n == nibble) {
                    return Err(ProofError::Crypto(
                        "Proof sibling collision: nibble already present".into(),
                    ));
                }
                children.push((nibble, current_hash));
                // Sort by nibble to match canonical encoding order.
                children.sort_by_key(|(n, _)| *n);
            }

            // Create InternalNode and compute hash
            let internal_node = InternalNode { children };

            // Node::hash for Internal uses sha256(encoded).
            // We wrap it in Node::Internal to use the standard Encode impl.
            let encoded = Node::Internal(internal_node).encode();
            let h = sha256(&encoded).map_err(|e| ProofError::Crypto(e.to_string()))?;

            let mut arr = [0u8; 32];
            arr.copy_from_slice(&h);
            current_hash = arr;
        }

        Ok(current_hash)
    }
}
