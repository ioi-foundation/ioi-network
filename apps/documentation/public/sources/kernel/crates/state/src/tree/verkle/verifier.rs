// Path: crates/commitment/src/tree/verkle/verifier.rs
use crate::primitives::kzg::{KZGCommitment, KZGCommitmentScheme, KZGParams, KZGProof};
use crate::tree::verkle::proof::VerklePathProof;
use crate::tree::verkle::verify::verify_path_with_scheme;
use ioi_types::app::Membership;
use ioi_types::error::ProofError;
use ioi_api::error::StateError;
use ioi_api::state::Verifier;
use parity_scale_codec::Decode;

/// A stateless verifier for proofs generated by a `VerkleTree` using a `KZGCommitmentScheme`.
#[derive(Clone, Debug)]
pub struct KZGVerifier {
    scheme: KZGCommitmentScheme,
}

impl KZGVerifier {
    /// Creates a new verifier with the necessary cryptographic parameters.
    pub fn new(params: KZGParams) -> Self {
        Self {
            scheme: KZGCommitmentScheme::new(params),
        }
    }
}

impl Verifier for KZGVerifier {
    type Commitment = KZGCommitment;
    type Proof = KZGProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(KZGCommitment::from(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof_obj: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> Result<(), ProofError> {
        let proof_bytes = proof_obj.as_ref();
        if proof_bytes.is_empty() {
            return Err(ProofError::InvalidExistence(
                "Proof data is empty".to_string(),
            ));
        }

        // Deserialize just to check the params_id and the terminal node against the outcome
        // before performing the more expensive cryptographic checks.
        let verkle_proof = VerklePathProof::decode(&mut &*proof_bytes)
            .map_err(|e| ProofError::Deserialization(e.to_string()))?;

        // Pre-check 1: Ensure the proof was generated with the same parameters we are using.
        let expected_params_id = self
            .scheme
            .params
            .fingerprint()
            .map_err(|e| ProofError::Crypto(e.to_string()))?;

        if verkle_proof.params_id != expected_params_id {
            log::warn!(
                "Verkle proof SRS fingerprint mismatch. Expected {}, got {}",
                hex::encode(expected_params_id),
                hex::encode(verkle_proof.params_id)
            );
            return Err(ProofError::InvalidExistence(
                "SRS fingerprint mismatch".to_string(),
            ));
        }

        // Pre-check 2: Ensure the outcome claimed by the Workload matches the proof's terminal node.
        let outcome_ok = match (outcome, &verkle_proof.terminal) {
            (Membership::Present(value), crate::tree::verkle::proof::Terminal::Leaf(payload)) => {
                value == payload
            }
            (Membership::Absent, terminal) => match terminal {
                // Absence is proven if the path ends at an empty slot, or at a neighbor leaf with a *different* key.
                crate::tree::verkle::proof::Terminal::Empty => true,
                crate::tree::verkle::proof::Terminal::Neighbor { key_stem, .. } => {
                    key != key_stem.as_slice()
                }
                _ => false, // e.g., claiming Absent but getting a Leaf for the same key.
            },
            _ => false, // Mismatched claim (e.g., Present) and proof type (e.g., Empty).
        };

        if !outcome_ok {
            log::warn!("Claimed membership outcome does not match Verkle proof's terminal node.");
            return Err(ProofError::InvalidExistence(
                "Claimed outcome does not match proof terminal".to_string(),
            ));
        }

        // Perform the full cryptographic verification.
        if verify_path_with_scheme(&self.scheme, root, &expected_params_id, key, proof_bytes) {
            Ok(())
        } else {
            Err(ProofError::RootMismatch)
        }
    }
}
