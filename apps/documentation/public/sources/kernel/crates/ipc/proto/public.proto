// Path: crates/ipc/proto/public.proto
syntax = "proto3";
package ioi.public.v1;

import "blockchain.proto";

service PublicApi {
  // Submit a transaction to the mempool/ingestion queue.
  // Returns immediately with a receipt (hash) or an approval request.
  rpc SubmitTransaction (SubmitTransactionRequest) returns (SubmitTransactionResponse);

  // Check the status of a transaction hash.
  rpc GetTransactionStatus (GetTransactionStatusRequest) returns (GetTransactionStatusResponse);

  // Proxy queries to the underlying Workload state (Merklized proof).
  rpc QueryState (ioi.blockchain.v1.QueryStateAtRequest) returns (ioi.blockchain.v1.QueryStateAtResponse);

  // Queries the raw state value directly from the latest committed state.
  rpc QueryRawState (ioi.blockchain.v1.QueryRawStateRequest) returns (ioi.blockchain.v1.QueryRawStateResponse);

  // Get the current status of the chain (Height, etc).
  rpc GetStatus (ioi.blockchain.v1.GetStatusRequest) returns (ioi.blockchain.v1.GetStatusResponse);

  // Get a block by its height.
  rpc GetBlockByHeight (GetBlockByHeightRequest) returns (GetBlockByHeightResponse);

  // [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
  // Critical for the "Visual Sovereignty" of the Autopilot GUI.
  rpc SubscribeEvents (SubscribeEventsRequest) returns (stream ChainEvent);

  // [NEW] Converts a natural language intent into a signable transaction payload.
  // This powers the "God Mode" search bar in the GUI.
  rpc DraftTransaction (DraftTransactionRequest) returns (DraftTransactionResponse);

  // [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
  // This allows the GUI to display the agent's visual memory.
  rpc GetContextBlob (GetContextBlobRequest) returns (GetContextBlobResponse);
}

message SubmitTransactionRequest {
    // Canonical SCALE-encoded bytes of the transaction.
    bytes transaction_bytes = 1;
}

message SubmitTransactionResponse {
    // SHA-256 hash of the transaction.
    // If status is PENDING_APPROVAL, this is the hash to sign in the ApprovalToken.
    string tx_hash = 1;
    
    // Indicates if the transaction was accepted, rejected, or requires 2FA.
    SubmissionStatus status = 2;
    
    // If PENDING_APPROVAL, this contains the human-readable reason (e.g. "Spend limit exceeded").
    string approval_reason = 3;
}

enum SubmissionStatus {
    ACCEPTED = 0;
    SUBMISSION_REJECTED = 1; // Renamed from REJECTED to avoid conflict
    PENDING_APPROVAL = 2; // "Suspended" state requiring user signature
}

message GetTransactionStatusRequest {
  string tx_hash = 1;
}

enum TxStatus {
  UNKNOWN = 0;
  PENDING = 1;
  IN_MEMPOOL = 2;
  COMMITTED = 3;
  REJECTED = 4;
}

message GetTransactionStatusResponse {
  TxStatus status = 1;
  string error_message = 2;
  uint64 block_height = 3;
}

message GetBlockByHeightRequest {
  uint64 height = 1;
}

message GetBlockByHeightResponse {
  bytes block_bytes = 1;
}

// --- Event Streaming Types ---

message SubscribeEventsRequest {
    // Optional filters could be added here (e.g. only "Action" events)
}

message ChainEvent {
    oneof event {
        // A block was successfully committed to the chain.
        BlockCommitted block = 1;
        
        // The agent is "thinking" (LLM token stream or internal monologue).
        AgentThought thought = 2;
        
        // The firewall intercepted an action.
        ActionIntercepted action = 3;
        
        // The status of a service or policy changed.
        SystemUpdate system = 4;

        // The user performed a physical input while in Ghost Mode.
        GhostInput ghost = 5;

        // The result of an executed action.
        AgentActionResult action_result = 6;
    }
}

message BlockCommitted {
    uint64 height = 1;
    string state_root = 2; // Hex
    uint64 tx_count = 3;
}

message AgentThought {
    string session_id = 1; // Hex
    string content = 2;    // The text token or reasoning step
    bool is_final = 3;     // True if this concludes the thought
    // [NEW] The hash of the visual context (screenshot) associated with this step.
    string visual_hash = 4;
}

message ActionIntercepted {
    string session_id = 1;
    string target = 2;     // e.g. "net::fetch"
    string verdict = 3;    // "ALLOW", "BLOCK", "REQUIRE_APPROVAL"
    string reason = 4;
}

message SystemUpdate {
    string component = 1;  // e.g. "P2P", "Mempool"
    string status = 2;
}

message GhostInput {
    string device = 1;      // "mouse", "keyboard"
    string description = 2; // "Click(100, 200)", "Type('hello')"
}

// [NEW] Message for action results
message AgentActionResult {
    string session_id = 1; // Hex
    uint32 step_index = 2;
    string tool_name = 3;
    string output = 4;
}

// --- Intent Drafting Types ---

message DraftTransactionRequest {
    // Natural language intent (e.g., "Send 50 tokens to Bob").
    string intent = 1;
    // Optional context to resolve names (e.g., "Bob" -> 0x123...).
    map<string, string> address_book = 2;
}

message DraftTransactionResponse {
    // The constructed, unsigned transaction bytes (SCALE encoded).
    bytes transaction_bytes = 1;
    
    // A structured summary for the UI to display before signing.
    string summary_markdown = 2;
    
    // The list of capabilities this transaction requires (for Policy check).
    repeated string required_capabilities = 3;
}

// --- Blob Retrieval Types ---

message GetContextBlobRequest {
  // Hex-encoded SHA-256 hash of the blob (e.g., visual_hash).
  string blob_hash = 1; 
}

message GetContextBlobResponse {
  // Raw bytes of the blob (e.g., PNG image).
  bytes data = 1;
  // Suggested MIME type (e.g. "image/png"). 
  // In a real implementation, this might be inferred or stored in metadata.
  string mime_type = 2; 
}